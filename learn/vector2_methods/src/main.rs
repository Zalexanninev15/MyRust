fn main() {
    // Добавлением элементов в вектор
    let mut list: Vec<i32> = vec![1, 2, 3, 4, 5];
    list.push(6);
    list.insert(2, 11); // Вставляем "11" на второе место, а "3" перемещается на четвёртое место
    list.insert(0, 0); // Вставляем "0" на первое место
    println!("{:?}", list);

    // Получение элемента из вектора
    // println!("{}", &list[0]); - лучше не использовать таким образом!!! может быть panic!!!
    // Лучше так
    let index: usize = 3;
    match list.get(index) {
        // Возвращает перечисление
        Some(el) => println!("Element is {}", el),
        None => println!("Element not found!"),
    }
    // Или так
    println!("{}", list.get(index).unwrap());
    // метод get для обработки потенциальных ошибок без остановки всей программы

    // Получение первого элемента из вектора
    println!("{}", list.first().unwrap());
    // Или так
    match list.first() {
        Some(el) => println!("First element is {}", el),
        None => println!("Element not found!"),
    }

    // Получение последнего элемента из вектора
    match list.last() {
        Some(el) => println!("Last element is {}", el),
        None => println!("Vector is empty!"),
    }

    // Получение длины вектора
    println!("Length is {}", list.len());

    // Проверка на пустоту
    let list1: Vec<i32> = vec![];
    if list1.is_empty() {
        println!("Vector is empty!");
    } else {
        println!("{:?}", list1);
    }

    // Ёмкость вектора (ВАЖНО)
    println!("{}", list.capacity()); // Сколько вектор может содержать элементов без перераспределения памяти
                                     /* Добавление элемента в вектор перераспределяет память, что сказывается на производительность, поэтому лучше
                                     с самого начала создавать вектор с заранее определённым количеством элементов
                                     Ёмкость вектора также зависит от типа данных вектора и увеличивается также при полном заполнении памяти под
                                     текущие элементы (зарезервированная память для элементов); ёмкость будет удваиваться */

    // Удаление элемента из вектора
    list.remove(2); // а также возвращает удалённый элемент (let ... = )
                    // Этот метод не влияет на выделенную память (ёмкость) вектора!!!
    list.pop(); // удаляет последний элемент из вектора и возвращает его (let ... = )
                // Этот метод не влияет на выделенную память (ёмкость) вектора!!!

    // Очистка вектора
    list.clear(); // удаляет все элементы из вектора
                  // Этот метод не влияет на выделенную память (ёмкость) вектора!!!

    // Урезать вектор
    let mut list2: Vec<i32> = vec![1, 2, 3, 4, 5];
    list2.truncate(2); // сколько первых элементов оставить
                       // Этот метод не влияет на выделенную память (ёмкость) вектора!!!
    println!("Capacity is {}\nVector: {:?}", list2.capacity(), list2);

    // Соединение двух векторов
    let mut list3: Vec<i32> = vec![1, 2, 3, 4, 5, 6, 7];
    println!(
        "Capacity is {}; Vector 3, old: {:?}",
        list3.capacity(),
        list3
    );
    list3.append(&mut list2); // вектор 2 становится пустым
    println!("Capacity is {}; Vector 3: {:?}", list3.capacity(), list3); // capacity old = 7; new capacity = 7*2=14
    println!("Capacity is {}; Vector 2: {:?}", list2.capacity(), list2);
}
